#!/usr/bin/env python3
"""
USB Vendor ID List Generator

Downloads the official USB-IF vendor IDs PDF and generates C++ source code
for UsbVendorList.cpp and UsbVendorList.h.

Requirements:
    pip install pymupdf requests

Usage:
    python generate_usb_vendor_list.py [--pdf-url URL] [--output-dir DIR]

Default PDF URL:
    https://www.usb.org/sites/default/files/vendor_ids121720_3.pdf
"""

import argparse
import re
import sys
from datetime import datetime
from pathlib import Path

try:
    import fitz  # PyMuPDF
    import requests
except ImportError as e:
    print(f"Missing required package: {e}")
    print("Install with: pip install pymupdf requests")
    sys.exit(1)


DEFAULT_PDF_URL = "https://www.usb.org/sites/default/files/vendor_ids121720_3.pdf"


def download_pdf(url: str, output_path: Path) -> None:
    """Download the PDF from the given URL."""
    print(f"Downloading PDF from {url}...")
    response = requests.get(url, timeout=60)
    response.raise_for_status()
    output_path.write_bytes(response.content)
    print(f"Saved to {output_path}")


def parse_pdf(pdf_path: Path) -> list[tuple[int, str]]:
    """
    Parse the USB vendor IDs PDF and extract vendor ID/name pairs.

    The PDF format has company names on one line followed by vendor ID (decimal) on the next line.

    Returns:
        List of (vendor_id, vendor_name) tuples, sorted by vendor_id.
    """
    print(f"Parsing PDF: {pdf_path}...")
    vendors = []

    doc = fitz.open(pdf_path)

    for page_num, page in enumerate(doc):
        text = page.get_text()
        lines = text.split('\n')

        # Process lines in pairs: company name followed by decimal vendor ID
        i = 0
        while i < len(lines):
            line = lines[i].strip()
            i += 1

            if not line:
                continue

            # Skip header lines
            if line.lower() in ('company', 'vendor id', '(decimal format)', 'vendor id (decimal format)'):
                continue

            # Check if this could be a company name (not a pure number)
            if line.isdigit():
                continue

            # Look for the next line which should be a decimal vendor ID
            while i < len(lines):
                next_line = lines[i].strip()
                i += 1

                if not next_line:
                    continue

                # Check if this is a decimal vendor ID
                if next_line.isdigit():
                    try:
                        vendor_id = int(next_line)
                        if 0 < vendor_id <= 0xFFFF:
                            vendors.append((vendor_id, line))
                    except ValueError:
                        pass
                    break
                else:
                    # Not a number, this line might be a new company name
                    # Put it back for next iteration
                    i -= 1
                    break

    doc.close()

    # Remove duplicates (keep first occurrence) and sort by vendor ID
    seen = set()
    unique_vendors = []
    for vendor_id, vendor_name in vendors:
        if vendor_id not in seen:
            seen.add(vendor_id)
            unique_vendors.append((vendor_id, vendor_name))

    unique_vendors.sort(key=lambda x: x[0])

    print(f"Found {len(unique_vendors)} unique vendor IDs")
    return unique_vendors


def escape_cpp_string(s: str) -> str:
    """Escape special characters for C++ wide string literal."""
    result = []
    for char in s:
        if char == '\\':
            result.append('\\\\')
        elif char == '"':
            result.append('\\"')
        elif char == '\n':
            result.append('\\n')
        elif char == '\r':
            result.append('\\r')
        elif char == '\t':
            result.append('\\t')
        elif ord(char) < 32 or ord(char) > 126:
            # Non-printable or non-ASCII: use Unicode escape
            result.append(f'\\x{ord(char):04x}')
        else:
            result.append(char)
    return ''.join(result)


def generate_cpp_header(output_path: Path, pdf_url: str) -> None:
    """Generate the UsbVendorList.h header file."""
    content = f'''\
// Auto-generated file - DO NOT EDIT MANUALLY
// Generated by scripts/generate_usb_vendor_list.py
// Source: {pdf_url}
// Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}

#pragma once

#include <string>
#include <Windows.h>

namespace KDM
{{

/// <summary>
/// Structure representing a USB vendor ID and name pair.
/// </summary>
struct UsbVendorInfo {{
    USHORT vendorId;
    const wchar_t* vendorName;
}};

/// <summary>
/// Retrieves the vendor name for a given USB vendor ID.
/// </summary>
/// <param name="vendorId">The USB vendor ID to look up</param>
/// <returns>The vendor name, or "Unknown" if not found</returns>
[[nodiscard]] const std::wstring GetVendorStringById(USHORT vendorId);

/// <summary>
/// Returns the total number of known USB vendors.
/// </summary>
[[nodiscard]] size_t GetVendorCount() noexcept;

}}  // namespace KDM
'''

    output_path.write_text(content, encoding='utf-8')
    print(f"Generated header: {output_path}")


def generate_cpp_source(output_path: Path, vendors: list[tuple[int, str]], pdf_url: str) -> None:
    """Generate the UsbVendorList.cpp source file."""

    # Build the vendor array entries
    vendor_entries = []
    for vendor_id, vendor_name in vendors:
        escaped_name = escape_cpp_string(vendor_name)
        vendor_entries.append(f'    {{0x{vendor_id:04X}, L"{escaped_name}"}}')

    vendor_array = ',\n'.join(vendor_entries)

    content = f'''\
// Auto-generated file - DO NOT EDIT MANUALLY
// Generated by scripts/generate_usb_vendor_list.py
// Source: {pdf_url}
// Generated: {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}
//
// To regenerate this file, run:
//     python scripts/generate_usb_vendor_list.py

#include "pch.h"
#include "UsbVendorList.h"

#include <algorithm>

namespace KDM
{{

// USB Vendor ID database
// Contains {len(vendors)} vendor entries
static const UsbVendorInfo g_usbVendors[] =
{{
{vendor_array}
}};

static constexpr size_t g_vendorCount = sizeof(g_usbVendors) / sizeof(g_usbVendors[0]);

const std::wstring GetVendorStringById(USHORT vendorId)
{{
    // Binary search for the vendor ID
    size_t left = 0;
    size_t right = g_vendorCount;

    while (left < right)
    {{
        size_t mid = left + (right - left) / 2;
        if (g_usbVendors[mid].vendorId < vendorId)
        {{
            left = mid + 1;
        }}
        else if (g_usbVendors[mid].vendorId > vendorId)
        {{
            right = mid;
        }}
        else
        {{
            return g_usbVendors[mid].vendorName;
        }}
    }}

    return L"Unknown";
}}

size_t GetVendorCount() noexcept
{{
    return g_vendorCount;
}}

}}  // namespace KDM
'''

    output_path.write_text(content, encoding='utf-8')
    print(f"Generated source: {output_path} ({len(vendors)} vendors)")


def main():
    parser = argparse.ArgumentParser(
        description="Generate USB vendor list C++ code from USB-IF PDF"
    )
    parser.add_argument(
        "--pdf-url",
        default=DEFAULT_PDF_URL,
        help=f"URL to the USB vendor IDs PDF (default: {DEFAULT_PDF_URL})"
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        default=None,
        help="Output directory for generated files (default: ../WinDevices/)"
    )
    parser.add_argument(
        "--keep-pdf",
        action="store_true",
        help="Keep the downloaded PDF file"
    )

    args = parser.parse_args()

    # Determine output directory
    script_dir = Path(__file__).parent
    if args.output_dir:
        output_dir = args.output_dir
    else:
        output_dir = script_dir.parent / "WinDevices"

    output_dir = output_dir.resolve()

    if not output_dir.exists():
        print(f"Error: Output directory does not exist: {output_dir}")
        sys.exit(1)

    # Download PDF
    pdf_path = script_dir / "vendor_ids.pdf"
    download_pdf(args.pdf_url, pdf_path)

    try:
        # Parse PDF
        vendors = parse_pdf(pdf_path)

        if not vendors:
            print("Error: No vendor IDs found in PDF")
            sys.exit(1)

        # Generate C++ files
        generate_cpp_header(output_dir / "UsbVendorList.h", args.pdf_url)
        generate_cpp_source(output_dir / "UsbVendorList.cpp", vendors, args.pdf_url)

        print(f"\nSuccessfully generated USB vendor list with {len(vendors)} entries")

        # Show some statistics
        print(f"\nVendor ID range: 0x{vendors[0][0]:04X} - 0x{vendors[-1][0]:04X}")

    finally:
        if not args.keep_pdf and pdf_path.exists():
            pdf_path.unlink()
            print(f"Cleaned up: {pdf_path}")


if __name__ == "__main__":
    main()
